

###  Two 3×3 kernels convolved with the original image to approximate the derivatives – one for horizontal changes, one for vertical.

import numpy as np

s_x = np.array([[-1,0,1],[-2,0,2],[-1,0,1]])
s_y = np.array([[-1,-2,-1],[0,0,0],[1,2,1]])


line_vertical = np.array([[0,10,0],[0,10,0],[0,10,0]])
line_horizontal = np.array([[0,0,0],[10,10,10],[0,0,0]])
line_diagonal_1 = np.array([[10,0,0],[0,10,0],[0,0,10]])
line_diagonal_2 = np.array([[0,0,10],[0,10,0],[10,0,0]])


sobel_list = [s_x, s_y]
sobel_names = ["s_x", "s_y"]
line_list  = [line_vertical, line_horizontal, line_diagonal_1, line_diagonal_2]
line_names  = ["line_vertical", "line_horizontal", "line_diagonal_1", "line_diagonal_2"]

s_count = 0
for s in sobel_list:
  l_count= 0
  for l in line_list:
    print("{} * {}\n{} \n* \n{} \n= \n{}\n\n".format(sobel_names[s_count], line_names[l_count], s, l, np.dot(s, l)))
    l_count += 1
  s_count += 1


