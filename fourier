import numpy as np

### Discrete Fourier Transformation -- of 'rank one' array a
### numbers with 'j' are complex numbers (e.g. 1j)
def DFT_naive(a):
    a = np.asarray(a, dtype=float)
    N = a.shape[0]
    n = np.arange(N)
    k = n.reshape((N, 1))
    M = np.exp(-2j * np.pi * k * n / N)
    return np.dot(M, a)
  
### compare against numpy Fast Fourier Transform
a = np.random.random(2048)
np.allclose(DFT_naive(a), np.fft.fft(a))

%timeit DFT_slow(a)
%timeit np.fft.fft(a)

def FFT_impl(a):
    """A recursive implementation of the 1D Cooley-Tukey FFT"""
    a = np.asarray(a, dtype=float)
    N = a.shape[0]
    
    if N % 2 > 0:
        raise ValueError("size of a must be a power of 2")
    elif N <= 32:  # this cutoff should be optimized
        return DFT_naive(a)
    else:
        A_even = FFT(a[::2])
        A_odd = FFT(a[1::2])
        factor = np.exp(-2j * np.pi * np.arange(N) / N)
        return np.concatenate([A_even + factor[:N / 2] * A_odd,
                               A_even + factor[N / 2:] * A_odd])

a = np.random.random(2048)
np.allclose(FFT(a), np.fft.fft(a))


%timeit DFT_naive(a)
%timeit FFT_impl(a)
%timeit np.fft.fft(a)
